
interface a2fPluginShaderInterface
{
    parameters(AtList list, AtMetaDataStore metadata);
    initialize(AtNode node, AtParamValue value);
    update(AtNode node, AtParamValue value);
    finish(AtNode node);

    evaluate(AtNode node, AtShaderGlobals globals);
};


/** 
 * We define an interface to the plugin mgr so kl2edk generates
 * an interface for us in the C++ side.
 */
interface ArnoldKLPluginIMgr
{
    // Call this function to register an implementation of one of the Arnold plugin interfaces
    RegisterKLPlugin!(Type kltype, SInt32 type, UInt8 output_type, String name, String filename);

    // This function is called by the C++ API to generate an instance of one of the plugins
    a2fPluginShaderInterface CreateInstance(String name);
};

/** 
 * Register an implementation of a KL interface matching the arnold
 * plugin node interfaces.  The kl type must inherit from an a2fPlugin interface
 */

function a2fPluginMgrRegisterPlugin(io ArnoldKLPluginIMgr mgr, SInt32 type, UInt8 output_type, String name, String filename) = "_fe_a2fRegisterPlugin";


object ArnoldKLPluginMgr : ArnoldKLPluginIMgr
{
    // Store a dictionary of all registered types
    Type[String] registeredPlugins;
};

function ArnoldKLPluginMgr.RegisterKLPlugin!(Type kltype, SInt32 type, UInt8 output_type, String name, String filename)
{
    // Save the type so we can create an instance on-demand
    this.registeredPlugins[name] = kltype;
    // Register the plugin within Arnolds plugin system
    ArnoldKLPluginIMgr imgr = this;
    a2fPluginMgrRegisterPlugin(imgr, type, output_type, name, filename);
}

function a2fPluginShaderInterface ArnoldKLPluginMgr.CreateInstance(String name)
{
    if (this.registeredPlugins.has(name))
        return this.registeredPlugins[name].createNew();
    return null;
}
