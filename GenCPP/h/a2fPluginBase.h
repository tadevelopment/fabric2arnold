#ifndef __KL2EDK_AUTOGEN_a2fPluginBase__
#define __KL2EDK_AUTOGEN_a2fPluginBase__

#ifdef KL2EDK_INCLUDE_MESSAGES
  #pragma message ( "Including 'a2fPluginBase.h'" )
#endif

////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
////////////////////////////////////////////////////////////////
// Generated by kl2edk version 1.15.3
////////////////////////////////////////////////////////////////

#include <FabricEDK.h>
#if FABRIC_EDK_VERSION_MAJ != 1 || FABRIC_EDK_VERSION_MIN != 15
# error "This file needs to be rebuilt for the current EDK version!"
#endif

#include "global.h"
#include "AtList.h"
#include "AtMetaDataStore.h"
#include "AtNode.h"
#include "AtParamValue.h"

namespace Fabric { namespace EDK { namespace KL {

// KL interface 'a2fPluginBase'

class a2fPluginBase
{
public:
  
  struct VTable
  {
    void (*parameters_1F388E0768F7A7207FCCC24F5AE59936)(
      ObjectCore const * const *objectCorePtr,
      Traits< AtList >::IOParam list,
      Traits< AtMetaDataStore >::IOParam metadata
      );
    void (*initialize_17AE8523DC66DB0F1469BAE1C26B4BBC)(
      ObjectCore * const *objectCorePtr,
      Traits< AtNode >::IOParam node,
      Traits< AtParamValue >::IOParam value
      );
    void (*update_EA7524D5A615AD89E2885946AF25AAED)(
      ObjectCore const * const *objectCorePtr,
      Traits< AtNode >::IOParam node,
      Traits< AtParamValue >::IOParam value
      );
    void (*finish_5998BBCD548026336476C84EA1A30F4D)(
      ObjectCore * const *objectCorePtr,
      Traits< AtNode >::IOParam node
      );
  };
  
  struct Bits
  {
    ObjectCore *objectCorePtr;
    SwapPtr<VTable const> const *vTableSwapPtrPtr;
  } *m_bits;
  
protected:
  
  friend struct Traits< a2fPluginBase >;
  
  static void ConstructEmpty( a2fPluginBase *self )
  {
    self->m_bits = 0;
  }
  
  static void ConstructCopy( a2fPluginBase *self, a2fPluginBase const *other )
  {
    if ( (self->m_bits = other->m_bits) )
      AtomicUInt32Increment( &self->m_bits->objectCorePtr->refCount );
  }
  
  static void AssignCopy( a2fPluginBase *self, a2fPluginBase const *other )
  {
    if ( self->m_bits != other->m_bits )
    {
      Destruct( self );
      ConstructCopy( self, other );
    }
  }
  
  static void Destruct( a2fPluginBase *self )
  {
    if ( self->m_bits
      && AtomicUInt32DecrementAndGetValue( &self->m_bits->objectCorePtr->refCount ) == 0 )
    {
      self->m_bits->objectCorePtr->lTableSwapPtrPtr->get()->lifecycleDestroy(
        &self->m_bits->objectCorePtr
        );
    }
  }
  
public: 
  
  typedef a2fPluginBase &Result;
  typedef a2fPluginBase const &INParam;
  typedef a2fPluginBase &IOParam;
  
  a2fPluginBase()
  {
    ConstructEmpty( this );
  }
  
  a2fPluginBase( a2fPluginBase const &that )
  {
    ConstructCopy( this, &that );
  }
  
  a2fPluginBase &operator =( a2fPluginBase const &that )
  {
    AssignCopy( this, &that );
    return *this;
  }
  
  ~a2fPluginBase()
  {
    Destruct( this );
  }
  
  void appendDesc( String::IOParam string ) const
  {
    if ( m_bits )
      m_bits->objectCorePtr->lTableSwapPtrPtr->get()->appendDesc( &m_bits->objectCorePtr, string );
    else string.append( "null", 4 );
  }
  
  bool isValid() const
  {
    return !!m_bits;
  }
  
  operator bool() const
  {
    return isValid();
  }
  
  bool operator !() const
  {
    return !isValid();
  }
  
  bool operator ==( INParam that )
  {
    return m_bits == that.m_bits;
  }
  
  bool operator !=( INParam that )
  {
    return m_bits != that.m_bits;
  }
  
  
  void parameters(
    Traits< AtList >::IOParam list,
    Traits< AtMetaDataStore >::IOParam metadata
    ) const
  {
    m_bits->vTableSwapPtrPtr->get()->parameters_1F388E0768F7A7207FCCC24F5AE59936(
      &m_bits->objectCorePtr,
      list,
      metadata
      );
  }
  
  void initialize(
    Traits< AtNode >::IOParam node,
    Traits< AtParamValue >::IOParam value
    )
  {
    m_bits->vTableSwapPtrPtr->get()->initialize_17AE8523DC66DB0F1469BAE1C26B4BBC(
      &m_bits->objectCorePtr,
      node,
      value
      );
  }
  
  void update(
    Traits< AtNode >::IOParam node,
    Traits< AtParamValue >::IOParam value
    ) const
  {
    m_bits->vTableSwapPtrPtr->get()->update_EA7524D5A615AD89E2885946AF25AAED(
      &m_bits->objectCorePtr,
      node,
      value
      );
  }
  
  void finish(
    Traits< AtNode >::IOParam node
    )
  {
    m_bits->vTableSwapPtrPtr->get()->finish_5998BBCD548026336476C84EA1A30F4D(
      &m_bits->objectCorePtr,
      node
      );
  }
};

inline void Traits<a2fPluginBase>::ConstructEmpty( a2fPluginBase &val )
{
  a2fPluginBase::ConstructEmpty( &val );
}
inline void Traits<a2fPluginBase>::ConstructCopy( a2fPluginBase &lhs, a2fPluginBase const &rhs )
{
  a2fPluginBase::ConstructCopy( &lhs, &rhs );
}
inline void Traits<a2fPluginBase>::AssignCopy( a2fPluginBase &lhs, a2fPluginBase const &rhs )
{
  a2fPluginBase::AssignCopy( &lhs, &rhs );
}
inline void Traits<a2fPluginBase>::Destruct( a2fPluginBase &val )
{
  a2fPluginBase::Destruct( &val );
}

}}}

#endif // __KL2EDK_AUTOGEN_a2fPluginBase__
