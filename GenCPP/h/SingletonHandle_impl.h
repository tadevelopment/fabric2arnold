#ifndef __KL2EDK_AUTOGEN_SingletonHandle_impl__
#define __KL2EDK_AUTOGEN_SingletonHandle_impl__

#ifdef KL2EDK_INCLUDE_MESSAGES
  #pragma message ( "Including 'SingletonHandle_impl.h'" )
#endif

////////////////////////////////////////////////////////////////
// THIS FILE IS AUTOMATICALLY GENERATED -- DO NOT MODIFY!!
////////////////////////////////////////////////////////////////
// Generated by kl2edk version 1.15.3
////////////////////////////////////////////////////////////////

#include <FabricEDK.h>
#if FABRIC_EDK_VERSION_MAJ != 1 || FABRIC_EDK_VERSION_MIN != 15
# error "This file needs to be rebuilt for the current EDK version!"
#endif

#include "global.h"

#include "SingletonHandle.h"

namespace Fabric { namespace EDK { namespace KL {

  struct SingletonHandle::Bits
  {
    ObjectCore __objectCore;
    Object::Bits __interfaceObjectBits;
  };
  
  inline void SingletonHandle::ConstructEmpty( SingletonHandle *self )
  {
    self->m_bits = 0;
  }
  
  inline void SingletonHandle::ConstructCopy( SingletonHandle *self, SingletonHandle const *other )
  {
    if ( (self->m_bits = other->m_bits) )
      AtomicUInt32Increment( &self->m_bits->__objectCore.refCount );
  }
  
  inline void SingletonHandle::AssignCopy( SingletonHandle *self, SingletonHandle const *other )
  {
    if ( self->m_bits != other->m_bits )
    {
      Destruct( self );
      ConstructCopy( self, other );
    }
  }
  
  inline void SingletonHandle::Destruct( SingletonHandle *self )
  {
    if ( self->m_bits
      && AtomicUInt32DecrementAndGetValue( &self->m_bits->__objectCore.refCount ) == 0 )
    {
      ObjectCore *objectCorePtr = &self->m_bits->__objectCore;
      self->m_bits->__objectCore.lTableSwapPtrPtr->get()->lifecycleDestroy(
        &objectCorePtr
        );
    }
  }
  
  inline SingletonHandle::SingletonHandle()
  {
    ConstructEmpty( this );
  }
  
  inline SingletonHandle SingletonHandle::Create()
  {
    static KL::SwapPtr<void> const *sp = 0;
    if ( !sp )
    {
      sp = static_cast<KL::SwapPtr<void> const *>(
        s_callbacks.m_lookupGlobalSymbol(
          "sp.function.kl.OO_SingletonHandle.createEmpty.io_AS0.OO_SingletonHandle",
          71
          )
        );
      if ( !sp )
        throwException(
          "EDK internal error: failed to look up '%s'",
          "sp.function.kl.OO_SingletonHandle.createEmpty.io_AS0.OO_SingletonHandle"
          );
    }
    void (*createFuncPtr)(void *) = ((void (*)(void *))sp->get());
    if ( !createFuncPtr )
      throwException(
        "EDK internal error: target of '%s' is NULL",
        "sp.function.kl.OO_SingletonHandle.createEmpty.io_AS0.OO_SingletonHandle"
        );
    SingletonHandle result;
    createFuncPtr( &result );
    return result;
  }
  
  inline SingletonHandle::SingletonHandle( SingletonHandle const &that )
  {
    ConstructCopy( this, &that );
  }
  
  inline SingletonHandle &SingletonHandle::operator =( SingletonHandle const &that )
  {
    AssignCopy( this, &that );
    return *this;
  }
  
  inline SingletonHandle::~SingletonHandle()
  {
    Destruct( this );
  }
  
  inline void SingletonHandle::appendDesc( String::IOParam string ) const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      objectCorePtr->lTableSwapPtrPtr->get()->appendDesc(
        &objectCorePtr, string
        );
    }
    else string.append( "null", 4 );
  }
  inline uint32_t SingletonHandle::getRefCount() const
  {
    if ( m_bits )
    {
      ObjectCore *objectCorePtr = &m_bits->__objectCore;
      return objectCorePtr->refCount;
    }
    else return 0;
  }
  inline Type SingletonHandle::getType() const
  {
    if ( m_bits )
    {
      return Type( m_bits->__objectCore.typeInfoSwapPtrPtr->get() );
    }
    else return Type();
  }
  
  inline bool SingletonHandle::isValid() const
  {
    return !!m_bits;
  }
  
  inline SingletonHandle::operator bool() const
  {
    return isValid();
  }
  
  inline bool SingletonHandle::operator !() const
  {
    return !isValid();
  }
  
  inline SingletonHandle::Bits *SingletonHandle::operator ->()
  {
    return static_cast<SingletonHandle::Bits *>( m_bits );
  }
  
  inline SingletonHandle::Bits const *SingletonHandle::operator ->() const
  {
    return static_cast<SingletonHandle::Bits const *>( m_bits );
  }
  
  inline bool SingletonHandle::operator ==( INParam that )
  {
    return m_bits == that.m_bits;
  }
  
  inline bool SingletonHandle::operator !=( INParam that )
  {
    return m_bits != that.m_bits;
  }
  
  // Methods for 'Object'

}}}

#endif // __KL2EDK_AUTOGEN_SingletonHandle_impl__
